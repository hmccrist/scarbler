{"version":3,"sources":["reportWebVitals.ts","components/rackSquare.tsx","components/rack.tsx","components/scarbleState.tsx","components/scrabbleSquare.tsx","components/scrabbleBoard.tsx","components/resultRow.tsx","components/resultsTabs.tsx","dict/anadict.ts","components/wordFinder.tsx","components/scarbler.tsx","components/rackState.tsx","index.tsx"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","useStyles","makeStyles","root","width","height","maxWidth","maxHeight","fontSize","textAlign","backgroundColor","fontFamily","border","boxShadow","RackSquare","props","styles","myRef","React","shouldFocus","current","focus","clearFocus","type","className","value","val","onChange","e","ref","display","flexGrow","justifyContent","columnGap","paddingBottom","Rack","classes","createProps","squareNumber","rackValues","focusValues","numToLetter","Map","getISCCoord","index","division","Math","floor","remainder","letter","get","position","input","color","textShadow","outline","flex","borderColor","ghostInput","arrows","left","top","pointerEvents","transform","ScrabbleSquare","selectionStart","length","selectionEnd","ghostValue","style","onMouseEnter","onMouseDown","onClick","tabIndex","visibility","displayArrow","background","flexDirection","row","squareColours","doubleLetterCoords","doubleWordCoords","tripleLetterCoords","tripleWordCoords","ScrabbleBoard","boardState","squareIndex","includes","coordinate","toString","displayArrows","ghostBoardState","boardJSX","squareCounter","i","squaresJSX","j","push","key","createBoard","section","ResultRow","bgColor","onHover","onMouseLeave","onHoverLeave","onMouseClick","word","score","dir","TabPanel","children","other","role","hidden","id","aria-labelledby","Box","Typography","component","a11yProps","theme","palette","paper","myTabs","myTab","indicator","lists","overflow","listHeaders","lineHeight","borderBottom","paddingTop","SimpleTabs","useState","setValue","AppBar","Tabs","event","newValue","aria-label","TabIndicatorProps","Tab","label","highestScoringList","disableRipple","longestScoringList","List","map","item","rackLetters","dataToStr","JSON","stringify","anadictData","strToObj","parse","anadict","default","dataToStr2","TWL06Data","strToObj2","TWL06Dict","Set","letterScores","startingSquareIndex","getAdjacentSquareIndex","currSquare","rowLength","boardSize","useWordFinder","Array","highestScoring","setHighestScoring","longestWords","setLongestWords","findAllPossibleWords","letterArr","letters","slice","sort","join","possibleWords","str1","array1","x","y","substring","combi","temp","slent","pow","add","from","substrings","forEach","combination","has","words","undefined","getNewWordScore","board","tempBoard","totalScore","totalNewWordScore","doubleMultipliers","tripleMultipliers","newLettersUsed","fullRackBonus","split","newLetter","letterScore","console","error","specialSquare","squareHasAdjacentLetters","createdNewWordScore","wordStartIndex","moveDir","nextSquare","getCreatedWordScore","getRackLettersNeeded","wordArr","rackLettersUsed","attemptPlaceWords","minLength","validWords","tempRackLetters","wordEncountered","placedLetter","boardLetter","boardWord","getWordOnBoard","letterIndex","indexOf","splice","validateWordOnBoard","validateWordPlacement","getAdjacentSquareIndexs","amount","indexs","nextIndex","rs","adjacentLetter1","adjacentLetter2","up","down","right","analyseBoard","rackArr","log","time","rackWords","allWords","allScrabbleWords","rightSquares","downSquares","rightLetters","downLetters","rightHasSpace","downHasSpace","spacesToRightLetter","spacesToDownLetter","rightHasAdjacent","spacesToRightAdjacent","spacesToDownAdjacent","downHasAdjacent","canPlaceWordRight","canPlaceWordDown","possibleRightWords","possibleDownWords","next","validRightWords","validDownWords","concat","min","w","rl","s","newScrabbleWord","allValidWords","timeEnd","highScoreScrabbleWords","a","b","longestScrabbleWords","clearScores","alignItems","margin","topRow","bottomRow","column","firstColumn","secondColumn","coordinates","Scarbler","maxScrabbleSquares","fill","setBoardState","setFocusValues","hoveredCoord","setHoveredCoord","ISCCoord","setISCCoord","setDisplayArrows","setGhostBoardState","getSquareIndex","changeFocus","newFocusValues","moveArrow","currArrowDir","newDisplayArrows","clearDisplayArrows","emptyDisplayArrows","placeWordOnBoard","newBoard","handleChange","scrabbleSquare","inputType","nativeEvent","newVal","data","arrowDir","newBoardValues","match","toUpperCase","handleMouseEnter","clearBoard","emptyBoardState","handleClick","currArrow","nextArrow","handleMouseExitBoard","exportBoardState","json","blob","Blob","FileSaver","saveAs","importBoardState","files","file","text","fileContent","importedBoard","validContent","err","handleHoverOnResultRow","scrabbleWord","emptyGhostBoardState","newGhostBoardState","handleHoverLeaveOnResultRow","handleClickOnResultRow","copyOfBoardState","newBoardState","useScarbleState","setRackValues","rackFocusValues","setRackFocusValues","changeFocusToSquare","handleRackChange","rackSquare","newRackValues","rackClearFocus","clearRack","removeLettersFromRack","useRackState","Button","variant","IconButton","accept","target","reducedRack","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.35b13568.chunk.js","sourcesContent":["import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import * as React from 'react';\r\nimport { makeStyles } from '@material-ui/core';\r\n\r\nconst useStyles = makeStyles ({\r\n    root: {\r\n        width: '3vw',\r\n        height: '3vw',\r\n        maxWidth: '1.25em',\r\n        maxHeight: '1.25em',\r\n        // fontSize: 48,\r\n        fontSize: 'min(2.5vw, 48px)', //38,\r\n        textAlign: 'center',\r\n        backgroundColor: 'lightyellow',\r\n        fontFamily: 'Verdana',\r\n        // outline: '1px solid gray',\r\n        border: '1px solid black',\r\n        boxShadow: 'inset 0 0 5px darkgray',\r\n    }\r\n}) \r\n\r\nexport type RackSquareProps = {\r\n    val: string,\r\n    onChange: (e: any) => void;\r\n    shouldFocus: boolean,\r\n    clearFocus: () => void;\r\n}\r\n\r\nexport function RackSquare(props: RackSquareProps) {\r\n    const styles = useStyles();\r\n    const myRef = React.useRef<HTMLInputElement>(null)\r\n\r\n    React.useEffect(() => {\r\n        if (props.shouldFocus && myRef.current !== null) {\r\n            myRef.current.focus();  // might need to keep on an eye on this, if there's any side effects im not aware of.\r\n            props.clearFocus()\r\n        }\r\n    })\r\n\r\n    return (\r\n        <input\r\n            type=\"text\"\r\n            className={styles.root}\r\n            value={props.val}\r\n            onChange={(e) => props.onChange(e)}\r\n            ref={myRef}\r\n        />\r\n    )\r\n}","import { makeStyles } from '@material-ui/core';\r\nimport * as React from 'react';\r\nimport { RackSquare, RackSquareProps } from './rackSquare';\r\n\r\nconst useStyles = makeStyles({\r\n    root: {\r\n        //background: 'linear-gradient(45deg, #9ed4ec 30%, #81c4e0 90%)',\r\n        //outline: '2px solid purple',\r\n        display: 'flex',\r\n        flexGrow: 1,\r\n        justifyContent: 'center',\r\n        columnGap: '0.125em',\r\n        paddingBottom: '1%',\r\n    },\r\n});\r\n\r\ntype RackProps = {\r\n    rackValues: string[],\r\n    onChange: (e: any, squareNumber: number) => void;\r\n    focusValues: boolean[],\r\n    clearFocus: () => void;\r\n}\r\n\r\nfunction Rack(props: RackProps) {\r\n    const classes = useStyles();\r\n\r\n    const createProps = (squareNumber: number): RackSquareProps => {\r\n        return {\r\n            val: props.rackValues[squareNumber],\r\n            onChange: (e) => props.onChange(e, squareNumber),\r\n            shouldFocus: props.focusValues[squareNumber],\r\n            clearFocus: () => props.clearFocus()\r\n        }\r\n\r\n    }\r\n\r\n    return (\r\n        <div className={classes.root}>\r\n            <RackSquare {...createProps(0)}/>\r\n            <RackSquare {...createProps(1)}/>\r\n            <RackSquare {...createProps(2)}/>\r\n            <RackSquare {...createProps(3)}/>\r\n            <RackSquare {...createProps(4)}/>\r\n            <RackSquare {...createProps(5)}/>\r\n            <RackSquare {...createProps(6)}/>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Rack;","import { useState } from 'react';\r\nimport FileSaver from 'file-saver';\r\nimport { ScrabbleWord } from './wordFinder';\r\n\r\n\r\n// hook\r\n\r\ntype Direction = 'up' | 'right' | 'down' | 'left';\r\nexport type ArrowType = 'right' | 'down' | null;\r\n\r\nconst numToLetter = new Map([\r\n    [1, \"A\"],\r\n    [2, \"B\"],\r\n    [3, \"C\"],\r\n    [4, \"D\"],\r\n    [5, \"E\"],\r\n    [6, \"F\"],\r\n    [7, \"G\"],\r\n    [8, \"H\"],\r\n    [9, \"I\"],\r\n    [10, \"J\"],\r\n    [11, \"K\"],\r\n    [12, \"L\"],\r\n    [13, \"M\"],\r\n    [14, \"N\"],\r\n    [15, \"O\"],\r\n])\r\n\r\nexport function getISCCoord(index: number): string {\r\n    let division = Math.floor(index / 15);\r\n    let remainder = index % 15;\r\n    let letter = numToLetter.get(division + 1)\r\n    return `${letter}${remainder + 1}`\r\n}\r\n\r\nexport function useScarbleState() {\r\n    const maxScrabbleSquares = 225;\r\n    const [boardState, setBoardState] = useState(Array<string>(maxScrabbleSquares).fill(''));\r\n    const [focusValues, setFocusValues] = useState(Array<boolean>(maxScrabbleSquares).fill(false));\r\n    const [hoveredCoord, setHoveredCoord] = useState('');\r\n    const [ISCCoord, setISCCoord] = useState('')\r\n    const [displayArrows, setDisplayArrows] = useState(Array<ArrowType>(maxScrabbleSquares).fill(null));\r\n    const [ghostBoardState, setGhostBoardState] = useState(Array<string>(maxScrabbleSquares).fill(''));\r\n\r\n    // Get the index of a square in a cardinal direction on the board. Doesn't wrap around/over/under board.\r\n    // Returns null if there is no square in that direction!\r\n    function getSquareIndex(currSquare: number, dir: Direction): number | null {\r\n        const rowLength = 15;\r\n        if (dir === \"right\") {\r\n            return currSquare % rowLength === rowLength - 1 ? null : currSquare + 1;\r\n        }\r\n        else if (dir === \"left\") {\r\n            return currSquare % rowLength === 0 ? null : currSquare - 1;\r\n        }\r\n        else if (dir === \"up\") {\r\n            return currSquare - rowLength < 0 ? null : currSquare - rowLength;\r\n        }\r\n        else if (dir === \"down\") {\r\n            return currSquare + rowLength > boardState.length ? null : currSquare + rowLength;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    function changeFocus(currSquare: number, dir: Direction): void {\r\n        const nextSquare = getSquareIndex(currSquare, dir);\r\n        if (nextSquare === null) {\r\n            return;\r\n        }\r\n        const newFocusValues = Array<boolean>(maxScrabbleSquares).fill(false);\r\n        newFocusValues[nextSquare] = true;\r\n        setFocusValues(newFocusValues);\r\n        //console.log(`changing focus to square: ${nextSquare}`);\r\n    }\r\n\r\n    function moveArrow(currSquare: number, dir: Direction): void {\r\n        const nextSquare = getSquareIndex(currSquare, dir);\r\n        const currArrowDir = displayArrows[currSquare];\r\n        if (nextSquare === null) {\r\n            return;\r\n        }\r\n        const newDisplayArrows = Array<ArrowType>(maxScrabbleSquares).fill(null);\r\n        newDisplayArrows[nextSquare] = currArrowDir;\r\n        setDisplayArrows(newDisplayArrows);\r\n    }\r\n\r\n    function clearFocus(): void {\r\n        const newFocusValues = Array<boolean>(maxScrabbleSquares).fill(false);\r\n        setFocusValues(newFocusValues);\r\n    }\r\n\r\n    function clearBoard(): void {\r\n        const emptyBoardState = Array<string>(maxScrabbleSquares).fill('');\r\n        setBoardState(emptyBoardState);\r\n    }\r\n\r\n    function clearDisplayArrows(): void {\r\n        const emptyDisplayArrows = Array<ArrowType>(maxScrabbleSquares).fill(null);\r\n        setDisplayArrows(emptyDisplayArrows);\r\n    }\r\n\r\n    function handleChange(e: any, scrabbleSquare: number): void {\r\n        const inputType = e.nativeEvent.inputType;\r\n        const newVal = e.nativeEvent.data;\r\n        const arrowDir = displayArrows[scrabbleSquare];\r\n        // arrowDir is null when the mouse exits the board and a square is still focused (and input is given)\r\n        if (arrowDir === null) {\r\n            return;\r\n        }\r\n        clearDisplayArrows()\r\n        \r\n        //console.log(`scrabbleSquare[${scrabbleSquare}] recieved input: ${inputType} val: ${newVal}`)\r\n        if (inputType === \"deleteContentBackward\" || inputType === \"deleteContentForward\") {\r\n            const newBoardValues = boardState.slice();\r\n            newBoardValues[scrabbleSquare] = '';\r\n            setBoardState(newBoardValues);\r\n            changeFocus(scrabbleSquare, arrowDir === 'right' ? 'left' : 'up');\r\n            moveArrow(scrabbleSquare, arrowDir === 'right' ? 'left' : 'up');\r\n            return;\r\n        }\r\n        if (newVal == null) {\r\n            return;\r\n        }\r\n        // regex checks if its any uppercase/lowercase letter from a-z\r\n        if (!newVal.match(/[A-Za-z]/)) {\r\n            return;\r\n        }\r\n        const newBoardValues = boardState.slice();\r\n        newBoardValues[scrabbleSquare] = newVal.toUpperCase();\r\n        changeFocus(scrabbleSquare, arrowDir);\r\n        moveArrow(scrabbleSquare, arrowDir);\r\n        setBoardState(newBoardValues);\r\n        return;\r\n    }\r\n\r\n    function handleMouseEnter(e: any, scrabbleSquare: number): void {\r\n        setHoveredCoord(scrabbleSquare.toString());\r\n        setISCCoord(getISCCoord(scrabbleSquare))\r\n        clearFocus();       // this might be inefficient? not sure, if performance issues change this func.\r\n    }\r\n\r\n    function handleClick(scrabbleSquare: number): void {\r\n        const currArrow = displayArrows[scrabbleSquare];\r\n        let nextArrow: ArrowType = null;\r\n        // cycle arrow from null -> right -> down\r\n        if (currArrow === null) {\r\n            nextArrow = 'right';\r\n        }\r\n        else if (currArrow === 'right') {\r\n            nextArrow = 'down';\r\n        }\r\n        else if (currArrow === 'down') {\r\n            nextArrow = 'right'\r\n        }\r\n        const newDisplayArrows = Array<ArrowType>(maxScrabbleSquares).fill(null);\r\n        newDisplayArrows[scrabbleSquare] = nextArrow;\r\n        setDisplayArrows(newDisplayArrows)\r\n    }\r\n\r\n    function handleMouseExitBoard(): void {\r\n        clearDisplayArrows();\r\n        clearFocus();\r\n        setHoveredCoord('');\r\n        setISCCoord('');\r\n    }\r\n\r\n    function exportBoardState(): void {\r\n        const json = JSON.stringify(boardState);\r\n        const blob = new Blob([json], {type: \"application/json\"})\r\n        FileSaver.saveAs(blob, \"scrabbleboard.json\");\r\n    }\r\n\r\n    function importBoardState(files: FileList | null): void {\r\n        if (files === null) { return; }\r\n        const file = files[0];\r\n        (async () => {\r\n            const fileContent = await file.text();\r\n            console.log(JSON.parse(fileContent));\r\n            const importedBoard: Array<string> = JSON.parse(fileContent);\r\n            // very simple check for a legit json file\r\n            let validContent = true;\r\n            try {\r\n                importedBoard.forEach((letter) => {\r\n                    if (letter.length > 1) { validContent = false; }\r\n                })\r\n            }\r\n            catch(err) {\r\n                validContent = false;\r\n                console.error('Invalid JSON file!')\r\n            }\r\n            if (validContent) { setBoardState(importedBoard) }\r\n            else { console.error(\"Invalid JSON file!\")}\r\n        })()\r\n        \r\n    }\r\n\r\n    function placeWordOnBoard(word: string, index: number, dir: 'right' | 'down', board: Array<string>): Array<string> {\r\n        const newBoard = board.slice();\r\n        const wordArr = word.split('');\r\n        let currSquare = index;\r\n        wordArr.forEach((letter) => {\r\n            newBoard[currSquare] = letter;\r\n            const nextSquare = getSquareIndex(currSquare, dir);\r\n            if (nextSquare !== null) { currSquare = nextSquare; }\r\n        })\r\n        return newBoard;\r\n    }\r\n\r\n    function handleHoverOnResultRow(scrabbleWord: ScrabbleWord): void {\r\n        const emptyGhostBoardState = Array<string>(maxScrabbleSquares).fill('');\r\n        const newGhostBoardState = placeWordOnBoard(scrabbleWord.word, scrabbleWord.index, scrabbleWord.dir, emptyGhostBoardState);\r\n        setGhostBoardState(newGhostBoardState);\r\n    }\r\n\r\n    function handleHoverLeaveOnResultRow(): void {\r\n        const emptyGhostBoardState = Array<string>(maxScrabbleSquares).fill('');\r\n        setGhostBoardState(emptyGhostBoardState);\r\n    }\r\n\r\n    function handleClickOnResultRow(scrabbleWord: ScrabbleWord): Array<string> {\r\n        const copyOfBoardState = boardState.slice();\r\n        const newBoardState = placeWordOnBoard(scrabbleWord.word, scrabbleWord.index, scrabbleWord.dir, copyOfBoardState);\r\n        setBoardState(newBoardState);\r\n        return newBoardState;\r\n    }\r\n    \r\n\r\n    return {\r\n        boardState,\r\n        handleChange,\r\n        focusValues,\r\n        handleMouseEnter,\r\n        hoveredCoord,\r\n        ISCCoord,\r\n        clearBoard,\r\n        displayArrows,\r\n        handleClick,\r\n        handleMouseExitBoard,\r\n        exportBoardState,\r\n        importBoardState,\r\n        ghostBoardState,\r\n        handleHoverOnResultRow,\r\n        handleHoverLeaveOnResultRow,\r\n        handleClickOnResultRow,\r\n    }\r\n}","import { makeStyles } from '@material-ui/core';\r\nimport * as React from 'react';\r\nimport KeyboardArrowRightSharpIcon from '@material-ui/icons/KeyboardArrowRightSharp';\r\nimport KeyboardArrowDownSharpIcon from '@material-ui/icons/KeyboardArrowDownSharp';\r\nimport { ArrowType } from './scarbleState';\r\n\r\nconst useStyles = makeStyles ({\r\n    root: {\r\n        position: 'relative',\r\n    },\r\n    input: {\r\n        //width: '1.5em', //'50px',\r\n        //height: '1.5em', //'50px',\r\n        width: '3vw', //'2.5vw',\r\n        height: '3vw', //'2.5vw',\r\n        maxWidth: '60px',\r\n        maxHeight: '60px',\r\n        display: 'block',   // this is important for resizing\r\n        fontSize: 'min(2.5vw, 38px)', //38,\r\n        textAlign: 'center',\r\n        backgroundColor: 'lightgreen',\r\n        fontFamily: 'Verdana',\r\n        border: '1px solid black',\r\n        color: 'transparent',\r\n        textShadow: '0 0 0 black',  // font color\r\n        outline: 'none',\r\n        flex: 1,\r\n        '&:hover': {\r\n            borderColor: '#9ecaed',\r\n            outline: 'none',\r\n            // boxShadow: '0 0 5px darkgray',\r\n        },\r\n        '&:focus': {\r\n            borderColor: 'none',\r\n            outline: 'none',\r\n        }\r\n    },\r\n    ghostInput: {\r\n        width: '3vw',\r\n        height: '3vw',\r\n        maxWidth: '60px',\r\n        maxHeight: '60px',\r\n        display: 'block',   // this is important for resizing\r\n        fontSize: 'min(2.5vw, 38px)',\r\n        textAlign: 'center',\r\n        backgroundColor: 'lightgreen',\r\n        fontFamily: 'Verdana',\r\n        border: '1px solid #9ecaed',\r\n        color: 'transparent',\r\n        textShadow: '0 0 0 #ffffff',  // font color\r\n        outline: 'none',\r\n        flex: 1,\r\n    },\r\n    arrows: {\r\n        position: 'absolute',\r\n        left: '25%',\r\n        top: '25%',\r\n        color: 'lightgreen',\r\n        pointerEvents: 'none',\r\n        transform: 'scale(1.5)',\r\n    }\r\n}) \r\n\r\nexport type ScrabbleSquareProps = {\r\n    value: string,\r\n    onChange: (e: any) => void;\r\n    shouldFocus: boolean,\r\n    color: string,\r\n    coordinate: string,\r\n    onMouseEnter: (e: any) => void,\r\n    displayArrow: ArrowType,\r\n    onClick: () => void,\r\n    ghostValue: string,\r\n}\r\n\r\n\r\nexport function ScrabbleSquare(props: ScrabbleSquareProps) {\r\n    const styles = useStyles()\r\n    const myRef = React.useRef<HTMLInputElement>(null)\r\n\r\n    React.useEffect(() => {\r\n        if (props.shouldFocus && myRef.current !== null) {\r\n            myRef.current.focus();  // might need to keep on an eye on this, if there's any side effects im not aware of.\r\n        }\r\n        // This sets cursor position always to the end of the input field.\r\n        if (myRef.current !== null) {\r\n            myRef.current.selectionStart = myRef.current.value.length;\r\n            myRef.current.selectionEnd = myRef.current.value.length;\r\n        }\r\n    })\r\n\r\n    return (\r\n        <div className={styles.root}>\r\n            <input\r\n                type=\"text\"\r\n                className={props.ghostValue === '' ? styles.input : styles.ghostInput}\r\n                style={{ backgroundColor: props.color}}\r\n                value={props.ghostValue === '' ? props.value : props.ghostValue}\r\n                onChange={(e) => props.onChange(e)}     // todo QOL: make this different so it captures backspaces on empty squares.\r\n                onMouseEnter={(e) => props.onMouseEnter(e)}\r\n                // onClick={() => props.onClick()}\r\n                onMouseDown={() => props.onClick()}     // This works better than onClick.\r\n                tabIndex={-1}\r\n                ref={myRef}\r\n            />\r\n            <KeyboardArrowDownSharpIcon className={styles.arrows} visibility={props.displayArrow === 'down' ? 'visible' : 'hidden'}/>\r\n            <KeyboardArrowRightSharpIcon className={styles.arrows} visibility={props.displayArrow === 'right' ? 'visible' : 'hidden'}/>\r\n        </div>\r\n\r\n    )\r\n}","import * as React from 'react';\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport { ScrabbleSquare, ScrabbleSquareProps } from './scrabbleSquare';\r\nimport { ArrowType } from './scarbleState';\r\n\r\nconst useStyles = makeStyles({\r\n    root: {\r\n        background: 'linear-gradient(45deg, #3884a7 30%, #56aad1 90%)',\r\n        color: 'white',\r\n        border: '1px solid black',\r\n        display: 'block',\r\n        flexDirection: 'column',\r\n        //maxWidth: '100%',\r\n        //height: '100%',\r\n        //maxHeight: '100%',\r\n    },\r\n    row: {\r\n        width: '100%',\r\n        height: '100%',\r\n\t\tdisplay: 'flex',\r\n\t\tflexDirection: 'row',\r\n    }\r\n});\r\n\r\n\r\nconst squareColours = {\r\n    colour1: 'rgb(100, 100, 100)',\r\n    colour2: 'rgb(105, 105, 105)',\r\n    doubleLetterColor: 'rgb(59, 108, 122)',\r\n    doubleWordColor: 'rgb(118, 67, 67)',\r\n    tripleLetterColor: 'rgb(5, 68, 85)',\r\n    tripleWordColor: 'rgb(73, 34, 34)',\r\n}\r\n\r\nconst doubleLetterCoords = [3, 11, 36, 38, 45, 52, 59, 92, 96, 98, 102, 108, 116, 122, 126, 128, 132, 165, 172, 179, 186, 188, 213, 221]\r\nconst doubleWordCoords = [16, 28, 32, 42, 48, 56, 64, 70, 112, 154, 160, 168, 176, 182, 192, 196, 208]\r\nconst tripleLetterCoords = [20, 24, 76, 80, 84, 88, 136, 140, 144, 148, 200, 204]\r\nconst tripleWordCoords = [0, 7, 14, 105, 119, 210, 217, 224]\r\n\r\nfunction getSquareColor(squareIndex: number): string {\r\n    if (doubleLetterCoords.includes(squareIndex)) {\r\n        return squareColours.doubleLetterColor;\r\n    }\r\n    else if (doubleWordCoords.includes(squareIndex)) {\r\n        return squareColours.doubleWordColor;\r\n    }\r\n    else if (tripleLetterCoords.includes(squareIndex)) {\r\n        return squareColours.tripleLetterColor;\r\n    }\r\n    else if (tripleWordCoords.includes(squareIndex)) {\r\n        return squareColours.tripleWordColor;\r\n    }\r\n\r\n    if (squareIndex % 2 === 0) {\r\n        return squareColours.colour1;\r\n    }\r\n    return squareColours.colour2;\r\n}\r\n\r\nexport type ScrabbleBoardProps = {\r\n    boardState: string[],\r\n    onChange: (e: any, squareNumber: number) => void;\r\n    focusValues: boolean[],\r\n    onMouseEnter: (e: any, squareNumber: number) => void;\r\n    displayArrows: ArrowType[],\r\n    onClick: (squareNumber: number) => void;\r\n    ghostBoardState: string[],\r\n}\r\n\r\nfunction ScrabbleBoard(props: ScrabbleBoardProps) {\r\n    const styles = useStyles()\r\n\r\n    function createProps(squareNumber: number): ScrabbleSquareProps {\r\n        return {\r\n            value: props.boardState[squareNumber],\r\n            onChange: (e) => props.onChange(e, squareNumber),\r\n            shouldFocus: props.focusValues[squareNumber],\r\n            color: getSquareColor(squareNumber),\r\n            coordinate: squareNumber.toString(),\r\n            onMouseEnter: (e) => props.onMouseEnter(e, squareNumber),\r\n            displayArrow: props.displayArrows[squareNumber],\r\n            onClick: () => props.onClick(squareNumber),\r\n            ghostValue: props.ghostBoardState[squareNumber],\r\n        }\r\n    }\r\n\r\n    function createBoard() {\r\n        let boardJSX = [];\r\n        let squareCounter = 0;\r\n        for (let i = 0; i < 15; i++) {\r\n            let squaresJSX = []\r\n            for (let j = 0; j < 15; j++) {\r\n                squaresJSX.push(<ScrabbleSquare {...createProps(squareCounter)} key={squareCounter} />);\r\n                squareCounter++;\r\n            }\r\n            boardJSX.push(<div className={styles.row} key={i}>{squaresJSX}</div>);\r\n        }\r\n        return boardJSX;\r\n    }\r\n\r\n    return (\r\n        <div className={styles.root}>\r\n            {createBoard()}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default ScrabbleBoard;","import { makeStyles } from '@material-ui/core';\r\nimport React from 'react';\r\nimport { getISCCoord } from './scarbleState';\r\n\r\nconst useStyles = makeStyles ({\r\n    root: {\r\n        display: 'flex',\r\n        flexDirection: 'row',\r\n        justifyContent: 'center',\r\n        border: '1px solid white',\r\n        //fontFamily: 'Verdana',\r\n        // fontSize: 18,\r\n        fontSize: 'min(2vw, 18px)',\r\n        '&:hover': {\r\n            border: '1px solid #9ecaed',\r\n            outline: 'none',\r\n        },\r\n    },\r\n    section: {\r\n        width: '30%',\r\n    }\r\n})\r\n\r\ntype ResultRowProps = {\r\n    word: string,\r\n    score: number,\r\n    index: number,\r\n    dir: string,\r\n    bgColor: string,\r\n    onHover: () => void;\r\n    onHoverLeave: () => void;\r\n    onMouseClick: () => void;\r\n}\r\n\r\nexport function ResultRow(props: ResultRowProps) {\r\n    const styles = useStyles();\r\n\r\n    return (\r\n        <div \r\n        className={styles.root} \r\n        style={{backgroundColor: props.bgColor}} \r\n        onMouseEnter={() => props.onHover()}\r\n        onMouseLeave={() => props.onHoverLeave()}\r\n        onMouseDown={() => props.onMouseClick()}\r\n        >\r\n            <div className={styles.section}> <p style={{fontFamily: 'Verdana'}}>{props.word}</p> </div>\r\n            <div className={styles.section}> <p >{props.score}</p> </div>\r\n            <div className={styles.section}> <p>{`${props.index}/${getISCCoord(props.index)} ${props.dir === 'right' ? '→' : '↓'}`}</p> </div>\r\n        </div>\r\n    )\r\n}","import React from 'react';\r\nimport { makeStyles, Theme } from '@material-ui/core/styles';\r\nimport AppBar from '@material-ui/core/AppBar';\r\nimport Tabs from '@material-ui/core/Tabs';\r\nimport Tab from '@material-ui/core/Tab';\r\nimport Typography from '@material-ui/core/Typography';\r\nimport Box from '@material-ui/core/Box';\r\nimport { List } from '@material-ui/core';\r\nimport { ScrabbleWord } from './wordFinder';\r\nimport { ResultRow } from './resultRow';\r\n\r\ninterface TabPanelProps {\r\n  children?: React.ReactNode;\r\n  index: any;\r\n  value: any;\r\n}\r\n\r\nfunction TabPanel(props: TabPanelProps) {\r\n  const { children, value, index, ...other } = props;\r\n\r\n  return (\r\n    <div\r\n      role=\"tabpanel\"\r\n      hidden={value !== index}\r\n      id={`simple-tabpanel-${index}`}\r\n      aria-labelledby={`simple-tab-${index}`}\r\n      {...other}\r\n    >\r\n      {value === index && (\r\n        <Box >\r\n          <Typography component={'span'} >{children}</Typography>\r\n        </Box>\r\n      )}\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction a11yProps(index: any) {\r\n  return {\r\n    id: `simple-tab-${index}`,\r\n    'aria-controls': `simple-tabpanel-${index}`,\r\n  };\r\n}\r\n\r\nconst useStyles = makeStyles((theme: Theme) => ({\r\n  root: {\r\n    flexGrow: 1,\r\n    backgroundColor: theme.palette.background.paper,\r\n    width: '25vw ',\r\n    maxWidth: '33em',\r\n  },\r\n  myTabs: {\r\n    color: 'black',\r\n    backgroundColor: 'white',\r\n    display: 'flex',\r\n    flexDirection: 'row',\r\n  },\r\n  myTab: {\r\n      background: 'darkgray',\r\n      flexGrow: 1,\r\n      fontSize: 'min(1.5vw, 15px)', //38,\r\n  },\r\n  indicator: {\r\n      background: 'black',\r\n  },\r\n  lists: {\r\n    height: '72vh',\r\n    maxHeight: '60em', //'80vh', //'51.5em',  // 700\r\n    overflow: 'auto',\r\n  },\r\n  listHeaders: {\r\n    display: 'flex',\r\n    flexDirection: 'row',\r\n    justifyContent: 'center',\r\n    lineHeight: '10%',\r\n    height: '1.75em',\r\n    backgroundColor: '#f0f0f0',\r\n    paddingBottom: '1%',\r\n    borderBottom: '1px solid lightgray',\r\n    '& p': {\r\n      width: '30%',\r\n      paddingTop: '0.15em', \r\n    }\r\n  }\r\n}));\r\n\r\ntype SimpleTabsProps = {\r\n    highestScoringList: Array<ScrabbleWord>,\r\n    longestScoringList: Array<ScrabbleWord>,\r\n    onHover: (scrabbleWord: ScrabbleWord) => void;\r\n    onHoverLeave: () => void;\r\n    onMouseClick: (scrabbleWord: ScrabbleWord) => void;\r\n}\r\n\r\nexport default function SimpleTabs(props: SimpleTabsProps) {\r\n  const classes = useStyles();\r\n  const [value, setValue] = React.useState(0);\r\n\r\n  const handleChange = (event: React.ChangeEvent<{}>, newValue: number) => {\r\n    setValue(newValue);\r\n  };\r\n\r\n  return (\r\n    <div className={classes.root}>\r\n      <AppBar position=\"static\">\r\n        <Tabs \r\n            value={value} \r\n            onChange={handleChange} \r\n            aria-label=\"simple tabs example\"\r\n            className={classes.myTabs}\r\n            TabIndicatorProps={{ className: classes.indicator}}\r\n            // variant='scrollable'\r\n            // scrollButtons='auto'\r\n        >\r\n          <Tab label={`Highest Scoring (${props.highestScoringList.length})`} className={classes.myTab} disableRipple {...a11yProps(0)} />\r\n          <Tab label={`Longest Words (${props.longestScoringList.length})`} className={classes.myTab} disableRipple {...a11yProps(1)} />\r\n          <Tab label=\"Custom Words\" className={classes.myTab} disableRipple {...a11yProps(2)} />\r\n        </Tabs>\r\n      </AppBar>\r\n      <TabPanel value={value} index={0}>\r\n      <div className={classes.listHeaders}> <p>Word</p> <p>Score</p> <p>Coordinate</p> </div>\r\n        <List className={classes.lists}>\r\n          {props.highestScoringList.map((item, i) => (\r\n              <li>\r\n              <ResultRow \r\n                word={item.word} \r\n                score={item.score} \r\n                index={item.index} \r\n                dir={item.dir} \r\n                bgColor={i % 2 === 0 ? 'rgb(220, 220, 220)' : 'rgb(210, 210, 210)'} \r\n                onHover={() => props.onHover(item)}\r\n                onHoverLeave={() => props.onHoverLeave()}\r\n                onMouseClick={() => props.onMouseClick(item)}\r\n              />\r\n              </li>\r\n          ))}\r\n        </List>\r\n      </TabPanel>\r\n      <TabPanel value={value} index={1}>\r\n        <div className={classes.listHeaders}> <p>Word</p> <p>Length</p> <p>Coordinate</p> </div>\r\n        <List className={classes.lists}>\r\n          {props.longestScoringList.map((item, i) => (\r\n              <li>\r\n              <ResultRow \r\n                word={item.word} \r\n                score={item.rackLetters.length} \r\n                index={item.index} dir={item.dir} \r\n                bgColor={i % 2 === 0 ? 'rgb(220, 220, 220)' : 'rgb(210, 210, 210)'} \r\n                onHover={() => props.onHover(item)}\r\n                onHoverLeave={() => props.onHoverLeave()}\r\n                onMouseClick={() => props.onMouseClick(item)}\r\n              />\r\n              </li>\r\n          ))}\r\n        </List>\r\n      </TabPanel>\r\n      <TabPanel value={value} index={2}>\r\n        todo\r\n      </TabPanel>\r\n    </div>\r\n  );\r\n}\r\n","import * as anadictData from './anadict.json'\r\nimport * as TWL06Data from './TWL06.json'\r\n\r\n// theres gotta be a better way to do this\r\n\r\nconst dataToStr = JSON.stringify(anadictData)\r\nconst strToObj = JSON.parse(dataToStr)\r\nconst objToMap = new Map<string, string[]>(strToObj.default)\r\n\r\nexport const anadict = objToMap;\r\n\r\nconst dataToStr2 = JSON.stringify(TWL06Data)\r\nconst strToObj2 = JSON.parse(dataToStr2)\r\nconst objToSet = new Set(strToObj2.default)\r\n\r\nexport const TWL06Dict = objToSet","import { useState } from \"react\";\r\nimport { anadict, TWL06Dict } from \"../dict/anadict\";\r\n\r\nconst letterScores = new Map([\r\n    [\"A\", 1],\r\n    [\"B\", 3],\r\n    [\"C\", 3],\r\n    [\"D\", 2],\r\n    [\"E\", 1],\r\n    [\"F\", 4],\r\n    [\"G\", 2],\r\n    [\"H\", 4],\r\n    [\"I\", 1],\r\n    [\"J\", 8],\r\n    [\"K\", 5],\r\n    [\"L\", 1],\r\n    [\"M\", 3],\r\n    [\"N\", 1],\r\n    [\"O\", 1],\r\n    [\"P\", 3],\r\n    [\"Q\", 10],\r\n    [\"R\", 1],\r\n    [\"S\", 1],\r\n    [\"T\", 1],\r\n    [\"U\", 1],\r\n    [\"V\", 4],\r\n    [\"W\", 4],\r\n    [\"X\", 8],\r\n    [\"Y\", 4],\r\n    [\"Z\", 10],\r\n])\r\n\r\nconst doubleLetterCoords = [3, 11, 36, 38, 45, 52, 59, 92, 96, 98, 102, 108, 116, 122, 126, 128, 132, 165, 172, 179, 186, 188, 213, 221]\r\nconst doubleWordCoords = [16, 28, 32, 42, 48, 56, 64, 70, 112, 154, 160, 168, 176, 182, 192, 196, 208]\r\nconst tripleLetterCoords = [20, 24, 76, 80, 84, 88, 136, 140, 144, 148, 200, 204]\r\nconst tripleWordCoords = [0, 7, 14, 105, 119, 210, 217, 224]\r\n\r\nconst startingSquareIndex: number = 112;    // The only square you can put a word down onto with no connections.\r\n\r\nexport type ScrabbleWord = {\r\n    word: string,\r\n    index: number,\r\n    dir: 'right' | 'down',\r\n    score: number,\r\n    rackLetters: Array<string>,\r\n}\r\n\r\n// yoinked online somewhere, returns an array of strings of every combination of a string.\r\n// does not return any duplicates.\r\nfunction substrings(str1: string): Array<string>\r\n{\r\n    var array1 = [];\r\n    for (var x = 0, y=1; x < str1.length; x++,y++) \r\n    {\r\n    array1[x]=str1.substring(x, y);\r\n        }\r\n    var combi = new Set<string>();\r\n    var temp= \"\";\r\n    var slent = Math.pow(2, array1.length);\r\n\r\n    for (var i = 0; i < slent ; i++)\r\n    {\r\n        temp= \"\";\r\n        for (var j=0;j<array1.length;j++) {\r\n            if ((i & Math.pow(2,j))){ \r\n                temp += array1[j];\r\n            }\r\n        }\r\n        if (temp !== \"\" && temp.length > 1)\r\n        {\r\n            combi.add(temp);\r\n        }\r\n    }\r\n    return(Array.from(combi));\r\n}\r\n\r\n// Helper function for getting adjacent squares on the board using the string array.\r\nfunction getAdjacentSquareIndex(currSquare: number, dir: 'left' | 'right' | 'down' | 'up'): number | null {\r\n    const boardSize = 225;\r\n    const rowLength = 15;   // how long the row on the board is\r\n    if (dir === \"right\") {\r\n        return currSquare % rowLength === rowLength - 1 ? null : currSquare + 1;\r\n    }\r\n    else if (dir === \"left\") {\r\n        return currSquare % rowLength === 0 ? null : currSquare - 1;\r\n    }\r\n    else if (dir === \"up\") {\r\n        return currSquare - rowLength < 0 ? null : currSquare - rowLength;\r\n    }\r\n    else if (dir === \"down\") {\r\n        return currSquare + rowLength > boardSize - 1 ? null : currSquare + rowLength;\r\n    }\r\n    return null;\r\n}\r\n\r\nexport function useWordFinder() {\r\n    const [highestScoring, setHighestScoring] = useState(Array<ScrabbleWord>());\r\n    const [longestWords, setLongestWords] = useState(Array<ScrabbleWord>());\r\n    //const [customWords, setCustomWords] = useState(Array<string>(MAX_ARRAY_SIZE).fill(''));\r\n\r\n    function findAllPossibleWords(letterArr: Array<string>): Array<string> {\r\n        const letters: string = letterArr.slice().sort().join('');          // slice copys it into a NEW array, sort alphabetically than flatten into string with join('')\r\n        //console.log(`Searching for all possible words with letters: ${letters}`)        //\r\n        let possibleWords: Array<string> = [];\r\n        const combinations = substrings(letters);\r\n        combinations.forEach((combination) => {\r\n            if (anadict.has(combination)) {\r\n                const words: string[] | undefined = anadict.get(combination);\r\n                if (words !== undefined) {\r\n                    words.forEach((word) => { possibleWords.push(word) })\r\n                }\r\n            }\r\n        })\r\n        \r\n        // console.log(`Found ${possibleWords.length} words: \\n${possibleWords}`)          //\r\n        return possibleWords;\r\n\r\n    }\r\n\r\n    function analyseBoard(board: Array<string>, rackArr: Array<string>): void {\r\n        console.log(\"starting board analysis...\")\r\n        console.time('anaylseBoard runtime: ')\r\n        const rackWords = findAllPossibleWords(rackArr);\r\n        let allWords: Array<string> = [];\r\n        let allScrabbleWords: Array<ScrabbleWord> = [];\r\n        //console.log(`ALL RACK WORDS: ${rackWords}`);\r\n\r\n        for (let i = 0; i < board.length; i++) {\r\n            // console.log(`# # # Checking square ${i} # # #`);\r\n            let rightSquares = getAdjacentSquareIndexs(i, 6, 'right');\r\n            let downSquares = getAdjacentSquareIndexs(i, 6, 'down');\r\n            let rightLetters: Array<string> = [];\r\n            let downLetters: Array<string> = [];\r\n            let rightHasSpace = false;\r\n            let downHasSpace = false;\r\n            let spacesToRightLetter = 99;\r\n            let spacesToDownLetter = 99;\r\n            let rightHasAdjacent = false;\r\n            let spacesToRightAdjacent = 99;\r\n            let spacesToDownAdjacent = 99;\r\n            let downHasAdjacent = false;\r\n            let canPlaceWordRight = true;\r\n            let canPlaceWordDown = true;\r\n            let possibleRightWords: Array<string> = [];\r\n            let possibleDownWords: Array<string> = [];\r\n\r\n            // Possible downSquares and rightSquares shouldn't stop until an empty space is found.\r\n            for (let i = 0; i < 15; i++) {\r\n                if (board[rightSquares[rightSquares.length-1]] !== '') {\r\n                    const next = (getAdjacentSquareIndex(rightSquares[rightSquares.length-1], 'right',));\r\n                    if (next === null) { break; }\r\n                    rightSquares.push(next);\r\n                }\r\n            }\r\n\r\n            for (let i = 0; i < 15; i++) {\r\n                if (board[downSquares[downSquares.length-1]] !== '') {\r\n                    const next = (getAdjacentSquareIndex(downSquares[downSquares.length-1], 'down',));\r\n                    if (next === null) { break; }\r\n                    downSquares.push(next);\r\n                }\r\n            }\r\n            \r\n            // Give rightLetters and downLetters there values, also checking if there are any adjacent squares.\r\n            rightSquares.forEach((val, index) => {\r\n                const letter = board[val];\r\n                if (letter === '') {\r\n                    rightHasSpace = true;\r\n                }\r\n                else {\r\n                    rightLetters.push(letter)\r\n                    if (spacesToRightLetter === 99) { spacesToRightLetter = index + 1; }\r\n                }\r\n                // check if it has adjacents\r\n                if (rightHasAdjacent === false && squareHasAdjacentLetters(board, val, 'vertical')) {\r\n                    rightHasAdjacent = true;\r\n                    spacesToRightAdjacent = index + 1;\r\n                }\r\n            })\r\n\r\n            downSquares.forEach((val, index) => {\r\n                const letter = board[val];\r\n                if (letter === '') {\r\n                    downHasSpace = true;\r\n                }\r\n                else {\r\n                    downLetters.push(letter);\r\n                    if (spacesToDownLetter === 99) { spacesToDownLetter = index + 1; }\r\n                }\r\n                // check if it has adjacents\r\n                if (downHasAdjacent === false && squareHasAdjacentLetters(board, val, 'horizontal')) {\r\n                    downHasAdjacent = true;\r\n                    spacesToDownAdjacent = index + 1;\r\n                }\r\n            })\r\n\r\n            // console.log(`hasRightAdjacents: ${rightHasAdjacent}`);\r\n            // console.log(`Spaces to rightAdjacentSquare = ${spacesToRightAdjacent}`)\r\n            // console.log(`rightLetters: ${rightLetters}`);\r\n\r\n            // console.log(`downSquares: ${downSquares}`)\r\n            // console.log(`hasDownAdjacents: ${downHasAdjacent}`);\r\n            // console.log(`Spaces to downAdjacentSquare = ${spacesToDownAdjacent}`)\r\n            // console.log(`downLetters: ${downLetters}`);\r\n\r\n            // If there are no spaces to place word OR all spaces are empty with no adjacents, then it is not possible to place a word.\r\n            // This doesn't matter if we're considering the center square.\r\n            if (!rightHasSpace || (rightLetters.length === 0 && !rightHasAdjacent)) {\r\n                canPlaceWordRight = false;\r\n            }\r\n            if (!downHasSpace || (downLetters.length === 0 && !downHasAdjacent)) {\r\n                canPlaceWordDown = false;\r\n            }\r\n\r\n            // Unique case for if the center square is involved.\r\n            if (rightSquares.includes(startingSquareIndex)) {\r\n                canPlaceWordRight = true;\r\n                spacesToRightLetter = rightSquares.indexOf(startingSquareIndex) + 1;\r\n            }\r\n            if (downSquares.includes(startingSquareIndex)) {\r\n                canPlaceWordDown = true;\r\n                spacesToDownLetter = downSquares.indexOf(startingSquareIndex) + 1;\r\n            }\r\n\r\n            if (!canPlaceWordRight && !canPlaceWordDown) {\r\n                continue;       // continue skips the rest of this particular loop, but doesn't break the entire for loop.\r\n            }\r\n\r\n\r\n            let validRightWords: Array<string> = [];\r\n            let validDownWords: Array<string> = [];\r\n\r\n            // If there are no new letters from the board we don't need to generate new words.\r\n            if (canPlaceWordRight) {\r\n                if (rightLetters.length === 0) {\r\n                    possibleRightWords = rackWords.slice();\r\n                    // console.log(`USING RACK WORDS BECAUSE THERE ARE NO BOARD LETTERS TO USE.`)\r\n                }\r\n                else {\r\n                    // Generate new possible words using rack letters + board letters.\r\n                    const allLetters: Array<string> = rackArr.concat(rightLetters);\r\n                    // console.log(\"all letters:\")\r\n                    // console.log(allLetters)\r\n                    possibleRightWords = findAllPossibleWords(allLetters);\r\n                    // console.log(\"all possible right words(not validated): \")\r\n                    // console.log(possibleRightWords);\r\n                }\r\n                validRightWords = attemptPlaceWords(board, possibleRightWords, 'right', i, Math.min(spacesToRightAdjacent, spacesToRightLetter), rackArr);\r\n            }\r\n                \r\n            if (canPlaceWordDown) {\r\n                if (downLetters.length === 0) {\r\n                    possibleDownWords = rackWords.slice()\r\n                }\r\n                else {\r\n                    const allLetters: Array<string> = rackArr.concat(downLetters);\r\n                    possibleDownWords = findAllPossibleWords(allLetters);\r\n                }\r\n                validDownWords = attemptPlaceWords(board, possibleDownWords, 'down', i, Math.min(spacesToDownAdjacent, spacesToDownLetter), rackArr);\r\n            }\r\n\r\n            // Transform the words into ScrabbleWord types\r\n            validRightWords.forEach((w) => {\r\n                const rl = getRackLettersNeeded(board, w, i, 'right');\r\n                const s = getNewWordScore(board, w, i, 'right');\r\n                const newScrabbleWord: ScrabbleWord = {\r\n                    word: w,\r\n                    index: i,\r\n                    dir: 'right',\r\n                    score: s, //getWordScore(w),\r\n                    rackLetters: rl\r\n                }\r\n                allScrabbleWords.push(newScrabbleWord);\r\n            })\r\n\r\n            validDownWords.forEach((w) => {\r\n                const rl = getRackLettersNeeded(board, w, i, 'down');\r\n                const s = getNewWordScore(board, w, i, 'down');\r\n                const newScrabbleWord: ScrabbleWord = {\r\n                    word: w,\r\n                    index: i,\r\n                    dir: 'down',\r\n                    score: s, //getWordScore(w),\r\n                    rackLetters: rl\r\n                }\r\n                allScrabbleWords.push(newScrabbleWord);\r\n            })\r\n\r\n            const allValidWords = validRightWords.concat(validDownWords);\r\n            allWords = allWords.concat(allValidWords);\r\n\r\n            //console.log(`ALL VALID WORDS:\\n${allValidWords}`);\r\n            // if(validRightWords.length > 0 ) { console.log(`ALL VALID RIGHT WORDS AT INDEX ${i}:\\n${validRightWords}`) }\r\n            // if (validDownWords.length > 0 ) { console.log(`\\nALL VALID DOWN WORDS AT INDEX ${i}:\\n${validDownWords}`) }\r\n\r\n            // console.log(\"\\n\")\r\n            \r\n\r\n\r\n        }\r\n        console.timeEnd('anaylseBoard runtime: ')\r\n        console.log(`words found: ${allWords.length}`)\r\n        //allScrabbleWords.sort((a, b) => b.score - a.score);\r\n        // console.log(allScrabbleWords);\r\n        const highScoreScrabbleWords = allScrabbleWords.slice().sort((a, b) => b.score - a.score);\r\n        const longestScrabbleWords = highScoreScrabbleWords.slice().sort((a,b) => b.rackLetters.length - a.rackLetters.length);\r\n        \r\n        setHighestScoring(highScoreScrabbleWords);\r\n        setLongestWords(longestScrabbleWords);\r\n\r\n    }\r\n\r\n    // new func for getting wordScores, takes the board into account now. (hopefully)\r\n    function getNewWordScore(board: Array<string>, word: string, index: number, dir: 'right' | 'down') {\r\n        const tempBoard = board.slice();\r\n        let totalScore = 0;\r\n        let totalNewWordScore = 0;  // This score doesn't get triple/double word bonuses.\r\n        let doubleMultipliers = 0;\r\n        let tripleMultipliers = 0;\r\n        let newLettersUsed = 0;\r\n        let fullRackBonus = false;\r\n        let currSquare = index;\r\n        const wordArr = word.split('');\r\n        wordArr.forEach((letter) => {\r\n            const boardLetter = tempBoard[currSquare];\r\n            let newLetter = boardLetter === '' ? true : false;\r\n            tempBoard[currSquare] = letter;\r\n            let letterScore = letterScores.get(letter);\r\n            if (letterScore === undefined) { console.error(\"letterScore is undefined for some reason\"); letterScore = 0;}\r\n            if (newLetter) {\r\n                newLettersUsed++;\r\n                let specialSquare: 'none' | 'doubleLetter' | 'doubleWord' | 'tripleLetter' | 'tripleWord' = 'none';\r\n                 if (doubleLetterCoords.includes(currSquare))       { letterScore *= 2; specialSquare = 'doubleLetter'; }\r\n                 else if (doubleWordCoords.includes(currSquare))    { doubleMultipliers++; specialSquare = 'doubleWord'; }\r\n                 else if (tripleLetterCoords.includes(currSquare))  { letterScore *= 3; specialSquare = 'tripleLetter'; }\r\n                 else if (tripleWordCoords.includes(currSquare))    { tripleMultipliers++; specialSquare = 'tripleWord'; }\r\n                 // Check if it created a new word (has adjacents on opposite axis)\r\n                 const createdNewWord = squareHasAdjacentLetters(tempBoard, currSquare, dir === 'right' ? 'vertical' : 'horizontal');\r\n                if (createdNewWord) {\r\n                    const createdNewWordScore = getCreatedWordScore(tempBoard, currSquare, dir === 'right' ? 'down' : 'right', specialSquare);\r\n                    totalNewWordScore += createdNewWordScore;\r\n                }\r\n            }\r\n            totalScore += letterScore;\r\n            let nextSquare = getAdjacentSquareIndex(currSquare, dir);\r\n            if (nextSquare !== null) { currSquare = nextSquare; }\r\n        })\r\n        if (newLettersUsed === 7) { fullRackBonus = true; }\r\n        for (let i = 0; i < doubleMultipliers; i++) {\r\n            totalScore *= 2;\r\n        }\r\n        for (let i = 0; i < tripleMultipliers; i++) {\r\n            totalScore *= 3;\r\n        }\r\n        if (fullRackBonus) { totalScore += 50; }\r\n        totalScore += totalNewWordScore;\r\n        return totalScore;\r\n    }\r\n\r\n    // for use in getNewWordScore. This is used when placing down a word, a new word is created adjacent to it, this calculates that new words score.\r\n    function getCreatedWordScore(board: Array<string>, index: number, dir: 'right' | 'down', specialSquare: 'none' | 'doubleLetter' | 'doubleWord' | 'tripleLetter' | 'tripleWord'): number {\r\n        // Go to start of word\r\n        // Read through each letter and add to totalScore, specialSquare only matters on initial index\r\n        let totalScore = 0;\r\n        let doubleMultipliers = 0;\r\n        let tripleMultipliers = 0;\r\n        if (board[index] === '') {\r\n            console.error(\"Tried to get word where this is no word! In getCreatedWordScore.\");\r\n            return 0;\r\n        }\r\n\r\n        let wordStartIndex = 0;\r\n        let currSquare = index;\r\n        let moveDir: 'left' | 'up' = dir === 'right' ? 'left' : 'up';\r\n        // find start of word\r\n        for (let i = 0; i < 15; i++) {\r\n            wordStartIndex = currSquare;\r\n            const nextSquare = getAdjacentSquareIndex(currSquare, moveDir);\r\n            if (nextSquare === null) { break; }\r\n            const nextSquareLetter = board[nextSquare];\r\n            if (nextSquareLetter === '') { break; }\r\n            currSquare = nextSquare;\r\n        }\r\n\r\n        // Go through and add up letter scores, only special square that matters is the one on index.\r\n        currSquare = wordStartIndex;\r\n        for (let i = 0; i < 15; i++) {\r\n            const letter = board[currSquare];\r\n            if (letter === null) { break; }\r\n            let letterScore = letterScores.get(letter);\r\n            if (letterScore === undefined) { console.error(\"letterScore is undefined\"); break;}\r\n            if (currSquare === index && specialSquare !== 'none') {\r\n                switch(specialSquare) {\r\n                    case 'doubleLetter':\r\n                        letterScore *= 2;\r\n                        break;\r\n                    case 'doubleWord':\r\n                        doubleMultipliers++;\r\n                        break;\r\n                    case 'tripleLetter':\r\n                        letterScore *= 3;\r\n                        break;\r\n                    case 'tripleWord':\r\n                        tripleMultipliers++;\r\n                        break;\r\n                }\r\n            }\r\n            totalScore += letterScore;\r\n            const nextSquare = getAdjacentSquareIndex(currSquare, dir);\r\n            if (nextSquare === null) { break; }\r\n            if (board[nextSquare] === '') { break; }\r\n            currSquare = nextSquare;\r\n        }\r\n        // Add multipliers and return\r\n        for (let i = 0; i < doubleMultipliers; i++) {\r\n            totalScore *= 2;\r\n        }\r\n        for (let i = 0; i < tripleMultipliers; i++) {\r\n            totalScore *= 3;\r\n        }\r\n        return totalScore;\r\n    }\r\n\r\n    function getRackLettersNeeded(board: Array<string>, word: string, index: number, dir: 'right' | 'down'): Array<string> {\r\n        const wordArr = word.split('');\r\n        let rackLettersUsed: Array<string> = [];\r\n        let currSquare = index;\r\n        wordArr.forEach((letter, i) => {\r\n            const boardLetter = board[currSquare];\r\n            if (boardLetter === '') {\r\n                rackLettersUsed.push(letter);\r\n            }\r\n            const nextSquare = getAdjacentSquareIndex(currSquare, dir);\r\n            if (nextSquare !== null) { currSquare = nextSquare};\r\n            if (nextSquare === null && i !== wordArr.length-1) { console.error(\"nextSquare should not be null in getRackLettersNeeded!\"); }\r\n        });\r\n        return rackLettersUsed;\r\n    }\r\n\r\n    // Attempts to place an array of possible words at a square location in a certain direction\r\n    // Returns any words that can be placed here legally.\r\n    function attemptPlaceWords(board: Array<string>, words: Array<string>, dir: 'right' | 'down', squareIndex: number, minLength: number, rackLetters: Array<string>): Array<string> {\r\n        let validWords: Array<string> = [];\r\n        words.forEach((word) =>  {\r\n            if (word.length >= minLength) {\r\n                const valid = validateWordPlacement(board, word, dir, squareIndex, rackLetters);\r\n                if (valid) { validWords.push(word) }\r\n            }\r\n        })\r\n        return validWords;\r\n    }\r\n\r\n    // Returns true/false if placing a word on the board at a certain location would be valid.\r\n    function validateWordPlacement(board: Array<string>, word: string, dir: 'right' | 'down', squareIndex: number, rackLetters: Array<string>): boolean {\r\n        // place each letter down on board, if there is not an empty space OR the space is occupied with a different letter return false\r\n        const tempBoard = board.slice();\r\n        const tempRackLetters = rackLetters.slice();\r\n        let currSquare = squareIndex;\r\n        let wordEncountered = false;\r\n        let placedLetter = false;       // if we didn't place a single letter, then we can not place a new word here.\r\n        for (let i = 0; i < word.length; i++) {\r\n            let boardLetter = tempBoard[currSquare];\r\n            if (boardLetter !== '' && boardLetter !== word[i]) {\r\n                return false;\r\n            }\r\n            // if we encounter a word on the board where we are placing, it HAS to be a substring of the word we want to place!\r\n            if (!wordEncountered && boardLetter !== '') {\r\n                const boardWord = getWordOnBoard(tempBoard, dir, currSquare);\r\n                wordEncountered = true;\r\n                if (!word.includes(boardWord)) { return false; }\r\n            }\r\n            else if (boardLetter === '') {\r\n                wordEncountered = false;\r\n                placedLetter = true;\r\n            }\r\n            // If we're placing a letter down on an empty space, take the letter from rackLetters. If the letter isn't in rackLetters, the word is invalid.\r\n            if (boardLetter === '') {\r\n                const letterIndex = tempRackLetters.indexOf(word[i]);\r\n                if (letterIndex < 0 ) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    tempRackLetters.splice(letterIndex, 1);\r\n                }\r\n            }\r\n            tempBoard[currSquare] = word[i];\r\n            // See if there's any adjacent letters\r\n            if (squareHasAdjacentLetters(tempBoard, currSquare, dir === 'right' ? 'vertical' : 'horizontal')) {\r\n                const valid = validateWordOnBoard(tempBoard, dir === 'right' ? 'down' : 'right', currSquare);\r\n                if (!valid) { return false; }\r\n            }\r\n            const nextSquare = getAdjacentSquareIndex(currSquare, dir);\r\n            if (nextSquare === null && i !== word.length - 1) { return false; }\r\n            if (nextSquare !== null) { currSquare = nextSquare; }\r\n        }\r\n        // Placed down entire word, just validate it then finish.\r\n        if (!placedLetter) { return false; }\r\n        const valid = validateWordOnBoard(tempBoard, dir, squareIndex);\r\n        return valid;\r\n    }\r\n\r\n    // If a word exists at this location on the board, then it will return true/false if it's scrabble valid for it to be here. (valid word with valid connections)\r\n    function validateWordOnBoard(board: Array<string>, dir: 'right' | 'down', squareIndex: number): boolean {\r\n        // check there's a letter at this location\r\n        if (board[squareIndex] === '') {\r\n            return false;\r\n        }\r\n        const word = getWordOnBoard(board, dir, squareIndex);\r\n        return TWL06Dict.has(word);\r\n    }\r\n\r\n    // Returns a word on the board in a certain direction.\r\n    // Does NOT check if the word is a real word or not. (use validateWordOnBoard for that)\r\n    function getWordOnBoard(board: Array<string>, dir: 'right' | 'down', squareIndex: number): string {\r\n        if (board[squareIndex] === '') {\r\n            console.error(\"Tried to get word where this is no word!\");\r\n            return '';\r\n        }\r\n\r\n        let wordStartIndex = 0;\r\n        let currSquare = squareIndex;\r\n        let moveDir: 'left' | 'up' = dir === 'right' ? 'left' : 'up';\r\n        // find start of word\r\n        for (let i = 0; i < 15; i++) {\r\n            wordStartIndex = currSquare;\r\n            const nextSquare = getAdjacentSquareIndex(currSquare, moveDir);\r\n            if (nextSquare === null) { break };\r\n            const nextSquareLetter = board[nextSquare];\r\n            if (nextSquareLetter === '') { break };\r\n            currSquare = nextSquare;\r\n        }\r\n\r\n        // read in the word\r\n        let word: Array<string> = [];\r\n        currSquare = wordStartIndex;\r\n        for (let i = 0; i < 15; i++) {\r\n            word.push(board[currSquare]);\r\n            const nextSquare = getAdjacentSquareIndex(currSquare, dir);\r\n            if (nextSquare === null) { break };\r\n            const nextSquareLetter = board[nextSquare];\r\n            if (nextSquareLetter === '') { break };\r\n            currSquare = nextSquare;\r\n        }\r\n        return (word.join(''));\r\n    }\r\n\r\n    // Includes the index that is passed in!\r\n    function getAdjacentSquareIndexs(index: number, amount: number, dir: 'left' | 'right' | 'down' | 'up'): Array<number> {\r\n        let indexs: Array<number> = [index];\r\n        let nextIndex = 0;\r\n        for (let i = 0; i < amount; i++) {\r\n            let rs = getAdjacentSquareIndex(index + nextIndex, dir);\r\n            if (rs === null) {\r\n                break;\r\n            }\r\n            indexs.push(rs);\r\n            switch (dir) {\r\n                case 'right': nextIndex += 1; break;\r\n                case 'left': nextIndex -= 1; break;\r\n                case 'up': nextIndex -= 15; break;\r\n                case 'down': nextIndex += 15; break;\r\n            }\r\n        }\r\n        return indexs;\r\n    }\r\n\r\n    function squareHasAdjacentLetters(board: Array<string>, index: number, dir: 'vertical' | 'horizontal'): boolean {\r\n        let adjacentLetter1: string = '';\r\n        let adjacentLetter2: string = '';\r\n        if (dir === 'vertical') {\r\n            const up = getAdjacentSquareIndex(index, 'up');\r\n            const down = getAdjacentSquareIndex(index, 'down')\r\n            if (up !== null) { adjacentLetter1 = board[up];}\r\n            if (down !== null) { adjacentLetter2 = board[down];}\r\n        }\r\n        else if (dir === 'horizontal') {\r\n            const right = getAdjacentSquareIndex(index, 'right');\r\n            const left = getAdjacentSquareIndex(index, 'left')\r\n            if (right !== null) { adjacentLetter1 = board[right];}\r\n            if (left !== null) { adjacentLetter2 = board[left];}\r\n        }\r\n        if (adjacentLetter1 !== '' || adjacentLetter2 !== '') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function clearScores(): void {\r\n        setHighestScoring(Array<ScrabbleWord>());\r\n        setLongestWords(Array<ScrabbleWord>());\r\n    }\r\n\r\n    return {\r\n        highestScoring,\r\n        longestWords,\r\n        analyseBoard,\r\n        clearScores,\r\n    }\r\n\r\n}\r\n\r\n","import { Button, IconButton, makeStyles } from '@material-ui/core';\r\nimport * as React from 'react';\r\nimport Rack from './rack';\r\nimport { useScarbleState } from './scarbleState';\r\nimport ScrabbleBoard from './scrabbleBoard';\r\nimport DeleteIcon from '@material-ui/icons/Delete'\r\nimport { useRackState } from './rackState';\r\nimport ResultsTabs from './resultsTabs';\r\nimport { useWordFinder } from './wordFinder';\r\nimport GetAppIcon from '@material-ui/icons/GetApp';\r\nimport PublishIcon from '@material-ui/icons/Publish';\r\n\r\nconst useStyles = makeStyles(() => ({\r\n    root: {\r\n\t\twidth: '100vw',//width: '100em',\r\n\t\theight: '100vh', //height: '70em',\r\n\t\tdisplay: 'flex',\r\n\t\tflexDirection: 'row',\r\n\t\tjustifyContent: 'center',\r\n        alignItems: 'center',\r\n        textAlign: 'center',\r\n        backgroundColor: 'lightgray',\r\n        margin: '0 auto',\r\n        // border: '1px solid purple', // debug\r\n    },\r\n\ttopRow: {\r\n        width: '100%',\r\n        height: '80%',\r\n\t\tdisplay: 'flex',\r\n        flexDirection: 'row',\r\n        //margin: '5px',\r\n        //outline: '2px solid green',\r\n        justifyContent: 'flex-start',\r\n        alignItems: 'center',\r\n        //columnGap: '1em'\r\n    },\r\n    bottomRow: {\r\n        width: '100%',\r\n\t\tdisplay: 'flex',\r\n\t\tflexDirection: 'row',\r\n        columnGap: '1em',\r\n        //outline: '2px solid green'\r\n    },\r\n    column: {\r\n\t\tdisplay: 'flex',\r\n\t\tflexDirection: 'column',\r\n\t\tjustifyContent: 'center',\r\n        alignItems: 'center',\r\n    },\r\n    row: {\r\n        display: 'flex',\r\n        flexDirection: 'row',\r\n        justifyContent: 'flex-start',\r\n        alignItems: 'flex-start',\r\n    },\r\n    firstColumn: {\r\n        display: 'flex',\r\n\t\tflexDirection: 'column',\r\n\t\tjustifyContent: 'center',\r\n        alignItems: 'center',\r\n        width: '65%',\r\n        height: '100%',\r\n        // outline: '1px solid blue',\r\n    },\r\n    secondColumn: {\r\n        display: 'flex',\r\n\t\tflexDirection: 'column',\r\n\t\tjustifyContent: 'flex-start',\r\n        alignItems: 'center',\r\n        width: '20%',\r\n        height: '100%',\r\n        // outline: '1px solid red',\r\n    },\r\n    coordinates: {\r\n        display: 'flex',\r\n        flexDirection: 'row',\r\n        justifyContent: 'center',\r\n        alignItems: 'center',\r\n        width: '50%',\r\n        columnGap: '20%',\r\n        //outline: '1px solid black'\r\n    },\r\n}));\r\n\r\nfunction Scarbler() {\r\n    const classes = useStyles()\r\n    const {\r\n        boardState,\r\n        handleChange,\r\n        focusValues,\r\n        handleMouseEnter,\r\n        hoveredCoord,\r\n        ISCCoord,\r\n        clearBoard,\r\n        displayArrows,\r\n        handleClick,\r\n        handleMouseExitBoard,\r\n        exportBoardState,\r\n        importBoardState,\r\n        ghostBoardState,\r\n        handleHoverOnResultRow,\r\n        handleHoverLeaveOnResultRow,\r\n        handleClickOnResultRow,\r\n    } = useScarbleState();\r\n\r\n    const {\r\n        rackValues,\r\n        handleRackChange,\r\n        rackFocusValues,\r\n        rackClearFocus,\r\n        clearRack,\r\n        removeLettersFromRack,\r\n    } = useRackState();\r\n\r\n    const {\r\n        highestScoring,\r\n        longestWords,\r\n        analyseBoard,\r\n        clearScores,\r\n    } = useWordFinder();\r\n\r\n    return (\r\n        <div className={classes.root}>\r\n            <div className={classes.topRow}>\r\n                {/**  First Column: Rack / Board */}\r\n                <div className={classes.firstColumn}>\r\n                    <div className={classes.coordinates}>\r\n                        <p>index: {hoveredCoord}</p>\r\n                        <p>ISCCoord: {ISCCoord}</p>\r\n                    </div>\r\n                    <Rack \r\n                            rackValues={rackValues}\r\n                            onChange={(e, squareNumber) => handleRackChange(e, squareNumber)}\r\n                            focusValues={rackFocusValues}\r\n                            clearFocus={() => rackClearFocus()}\r\n                    />\r\n                    <div onMouseLeave={() => handleMouseExitBoard()}>\r\n                    <ScrabbleBoard \r\n                            boardState={boardState} \r\n                            onChange={(e, squareNumber) => handleChange(e, squareNumber)} \r\n                            focusValues={focusValues}\r\n                            onMouseEnter={(e, squareNumber) => handleMouseEnter(e, squareNumber)}\r\n                            displayArrows={displayArrows}\r\n                            onClick={(squareNumber) => handleClick(squareNumber)}\r\n                            ghostBoardState={ghostBoardState}\r\n                    />\r\n                    </div>\r\n                </div>\r\n                {/**  Second Column: Buttons / Analysis Results */}\r\n                <div className={classes.secondColumn}>\r\n                    <div className={classes.row}>\r\n                        <Button variant=\"contained\" color=\"primary\" onClick={() => {analyseBoard(boardState, rackValues)}}>Analyse Board</Button>\r\n                        <IconButton aria-label=\"delete\" onClick={() => {clearBoard(); clearRack(); clearScores(); }}>\r\n                            <DeleteIcon />\r\n                        </IconButton>\r\n                        <IconButton onClick={() => exportBoardState()}>\r\n                            <GetAppIcon />\r\n                        </IconButton>\r\n                        <IconButton component=\"label\">   \r\n                            <PublishIcon/>\r\n                            <input type=\"file\" hidden accept=\".json\" onChange={(e) => {importBoardState(e.target.files); e.target.value=\"\"}}/>\r\n                        </IconButton>\r\n                    </div>\r\n                    <div className={classes.row}>\r\n                        <ResultsTabs \r\n                            highestScoringList={highestScoring} \r\n                            longestScoringList={longestWords} \r\n                            onHover={(item) => handleHoverOnResultRow(item)}\r\n                            onHoverLeave={() => handleHoverLeaveOnResultRow()}\r\n                            onMouseClick={(item) => {\r\n                                const newBoardState = handleClickOnResultRow(item); \r\n                                handleHoverLeaveOnResultRow(); \r\n                                const reducedRack = removeLettersFromRack(item.rackLetters); \r\n                                analyseBoard(newBoardState, reducedRack);\r\n                            }}\r\n                        />\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Scarbler","import { useState } from \"react\";\r\n\r\nexport function useRackState() {\r\n    const [rackValues, setRackValues] = useState(Array<string>(7).fill(''));\r\n    // an array of bools that whenever one is set to true the rackSquare will attempt to focus.\r\n    const [rackFocusValues, setRackFocusValues] = useState(Array<boolean>(7).fill(false));\r\n\r\n    function changeFocusToSquare(currSquare: number, dir: 'left' | 'right'): void {\r\n        let nextSquare: number = 0;\r\n        if (dir === 'right') {\r\n            if (currSquare + 1 > rackFocusValues.length - 1) {\r\n                return;\r\n            }\r\n            nextSquare = currSquare + 1;\r\n        }\r\n        else if (dir === 'left') {\r\n            if (currSquare - 1 < 0) {\r\n                return;\r\n            }\r\n            nextSquare = currSquare - 1;\r\n        }\r\n        const newFocusValues = Array<boolean>(7).fill(false);\r\n        newFocusValues[nextSquare] = true;\r\n        setRackFocusValues(newFocusValues);\r\n        //console.log(`changing focus to square: ${nextSquare}`)\r\n    }\r\n\r\n    function handleRackChange(e: any, rackSquare: number): void {\r\n        const inputType = e.nativeEvent.inputType;\r\n        const newVal = e.nativeEvent.data;\r\n        //console.log(`rackSquare[${rackSquare}] recieved input: ${inputType} val: ${newVal}`);\r\n        if (inputType === \"deleteContentBackward\" || inputType === \"deleteContentForward\") {\r\n            const newRackValues = rackValues.slice();\r\n            newRackValues[rackSquare] = '';\r\n            setRackValues(newRackValues);\r\n            changeFocusToSquare(rackSquare, 'left');\r\n            return;\r\n        }\r\n        if (newVal == null) {\r\n            return;\r\n        }\r\n        // regex checks if its any uppercase/lowercase letter from a-z\r\n        if (!newVal.match(/[A-Za-z]/)) {\r\n            return;\r\n        }\r\n        const newRackValues = rackValues.slice();\r\n        newRackValues[rackSquare] = newVal.toUpperCase();\r\n        changeFocusToSquare(rackSquare, 'right');\r\n        setRackValues(newRackValues);\r\n        return;\r\n    }\r\n\r\n    function clearRack() {\r\n        setRackValues(Array<string>(7).fill(''));\r\n    }\r\n\r\n    function rackClearFocus() {\r\n        const newFocusValues = Array<boolean>(7).fill(false)\r\n        setRackFocusValues(newFocusValues)\r\n    }\r\n\r\n    function removeLettersFromRack(letters: Array<string>): Array<string> {\r\n        const newRackValues = rackValues.slice();\r\n        letters.forEach((letter) =>  {\r\n            if (newRackValues.includes(letter)) {\r\n                const i = newRackValues.indexOf(letter);\r\n                newRackValues[i] = '';\r\n            }\r\n        })\r\n        newRackValues.sort((a ,b) => {\r\n            return b.length - a.length;\r\n        });\r\n        setRackValues(newRackValues);\r\n        return newRackValues;\r\n    }\r\n\r\n    return {\r\n        rackValues,\r\n        handleRackChange,\r\n        rackFocusValues,\r\n        rackClearFocus,\r\n        clearRack,\r\n        removeLettersFromRack,\r\n    }\r\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\nimport Scarbler from './components/scarbler';\n\nReactDOM.render(\n  <React.StrictMode>\n    <div>\n    <Scarbler />\n    </div>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}